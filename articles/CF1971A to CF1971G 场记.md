### Problem A. My First Sorting Problem

**【题意】**

给定 $x$ 和 $y$，求 $\min(x,y)$ 和 $\max(x,y)$。多测。

**【思路】**

模拟即可。

单组数据时间复杂度 $O(1)$。

**【代码】**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
const int N = 1e5 + 5;
int t, x, y;
signed main() {
	cin>>t;
	while(t--) {
		cin>>x>>y;
		cout<<min(x, y)<<" "<<max(x, y)<<endl;
	}
}
```

---

### Problem B. Different String

**【题意】**

给定字符串 $s$，求其的一个重排 $t$ 使得 $s\neq t$，或报告无解。多测。

**【思路】**

当且仅当 $s$ 中仅有一种字符，即 $s$ 中的每个字符均相同时，无解。

因此考虑将 $s$ 升序排序，若 $s_0=s_{|s|-1}$ 则无解，否则输出 $s$ 即可。

但是这样做可以被 $\tt aaab$ 轻松 Hack 掉，不信你可以去像我一样次罚时。于是不妨再降序排序一次，容易证明必定可行。

单组数据时间复杂度 $O(|s|\log|s|)$。

**【代码】**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
const int N = 1e5 + 5;
int t; string s, x;
signed main() {
	cin>>t;
	while(t--) {
		cin>>s; x = s;
		sort(x.begin(), x.end());
		if(s != x) {
			cout<<"YES"<<endl<<x<<endl;
			continue;
		}
		sort(x.begin(), x.end(), greater<char>());
		if(s != x) {
			cout<<"YES"<<endl<<x<<endl;
			continue;
		}
		cout<<"NO"<<endl;
	}
}
```

---

### Problem C. Clock and Strings

**【题意】**

在时钟上的 $1\sim12$ 刻度处有 $4$ 点 $A,B,C,D$，连接 $AB$ 和 $CD$，判断是否有交点。多测。

**【思路】**

令 $A(a),B(b),C(c),D(d)$。考虑将 $A$ 和 $B$ 交换，使得 $a\le b$，其余同理。

不难发现若四点满足 $a\le c\le b\le d$ 或是 $c\le a\le d\le b$ 则有交点，即 $[a,b]\cup[c,d]$ 不为 $\varnothing$。此处可以感性理解一下。

具体实现的时候可以先特判一下两点重合的情况。

单组数据时间复杂度 $O(1)$。

**【代码】**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
const int N = 1e5 + 5;
int a, b, c, d;
void solve() {
	cin>>a>>b>>c>>d;
	if(a == c || b == c || a == d || b == d) {
		cout<<"YES"<<endl;
		return;
	} else if(a == b || c == d) {
		cout<<"NO"<<endl;
		return;
	}
	if(a > b) swap(a, b);
	if(c > d) swap(c, d);
	if(a < c && c < b && b < d) {
		cout<<"YES"<<endl;
		return;
	}
	if(c < a && a < d && d < b) {
		cout<<"YES"<<endl;
		return;
	}
	cout<<"NO"<<endl;
}
int t;
signed main() {
	cin>>t;
	while(t--) solve();
}
```

---

### Problem D. Binary Cut

**【题意】**

给定 01 序列 $s$，试将 $s$ 分成尽可能少的连续子序列，使得将其重排后组成的序列单调不减。多测。

**【思路】**

考虑最终的 $t=\tt00\cdots0011\cdots11$，必定含有若干个 $\tt00\cdots00$ 和若干个 $\tt11\cdots11$，以及至多一个 $\tt00\cdots0011\cdots11$。例如，$\tt0001111$ 可以被分为 $\tt00~|~011~|~1~|~1$。

那么不妨用 $k$ 标记当前是否有形如 $\tt00\cdots0011\cdots11$ 的子序列。从前往后扫一遍 $s$，分割成若干个单调不减（当 $k=1$ 时需要保证均相同）的子序列，并统计个数即可。

单组数据时间复杂度 $O(|s|)$。

**【代码】**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
const int N = 1e5 + 5;
string s; int n, k, cnt;
void solve() {
	cin>>s; n = s.length(); s = " " + s;
	int i = 1; k = cnt = 0;
	while(i <= n) {
        // cout<<"i = "<<i<<endl;
		if(!k) {
            // cout<<"qwq"<<endl;
			while(i <= n && s[i + 1] >= s[i]) {
                if(s[i + 1] > s[i]) k = 1;
                i++;
            }
		} else while(i <= n && s[i + 1] == s[i]) i++;
		cnt++; i++;
	}
	cout<<cnt<<endl;
}
int t;
signed main() {
	cin>>t;
	while(t--) solve();
}
```

---

### Problem E. Find the Car

**【题意】**

数轴上有一点，在 $b_i$ 时刻到达 $a_i$ 处，设其在两个 $a_i$ 之间匀速通过。多次询问，查询何时到达 $d$ 处，四舍五入。多测。

**【思路】**

考虑先二分出查询的 $d$ 在哪个区间 $[a_i,a_{i+1}]$ 中。最终答案即为：

$$
\begin{aligned}
\text{ans}&=b_i+t \\
&=b_i+s\cdot v \\
&=b_i+(d-a_i)\cdot\dfrac{b_{i+1}-b_i}{a_{i+1}-a_i}
\end{aligned}
$$

注意多测清空，否则你会 WA on #2。

单组数据复杂度 $O(n+q\log n)$。

**【代码】**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
const int N = 1e5 + 5;
int n, k, q, a[N], b[N];
void solve() {
	cin>>n>>k>>q;
	for(int i = 1; i <= k; i++) cin>>a[i];
	for(int i = 1; i <= k; i++) cin>>b[i];
	a[k + 1] = b[k + 1] = 0;
	while(q--) {
		int d; cin>>d;
		int l = 0, r = k;
		while(l <= r) {
			int m = (l + r) / 2;
			if(a[m] > d) r = m - 1;
            else l = m + 1;
		}
		// if(a[r + 1] == a[r]) cout<<"qwq "<<r<<endl, exit(-1);
		cout<<b[r] + (d - a[r]) * (b[r + 1] - b[r]) / (a[r + 1] - a[r])<<" ";
	}
	cout<<endl;
}
int t;
signed main() {
	cin>>t;
	while(t--) solve();
}
```

---

### Problem F. Circle Perimeter

**【题意】**

给定 $r$，求满足 $r\le\sqrt{x^2+y^2}<r+1$ 的整点对 $(x,y)$ 的数量。多测。

**【思路】**

考虑坐标系除原点外可以被分成四个部分，而 $r\ge1$ 故原点对答案无贡献，因此仅计算第一象限部分的答案，再乘上 $4$ 即为最终答案。

不妨枚举 $0\le x\le r$，令 $y_{\max}$ 表示满足条件的最大 $y$ 值，而 $y_{\min}$ 同理，则其对答案的贡献为 $y_{\max}-y_{\min}+1$。于是答案为：

$$
\begin{aligned}
\text{ans}&=4\cdot\sum_{x=0}^{r}(y_{\max}-y_{\min}+1)
\end{aligned}
$$

接下来只需考虑如何求出对应的 $y$ 的最值即可。

由 $r\le\sqrt{x^2+y^2}<r+1$ 可得：

$$
\begin{aligned}
  &r\le\sqrt{x^2+y^2}<r+1 \\
  \Rightarrow~&r^2\le x^2+y^2<(r+1)^2 \\
  \Rightarrow~&r^2-x^2\le y^2<(r+1)^2-x^2 \\
  \Rightarrow~&\sqrt{r^2-x^2}\le y<\sqrt{(r+1)^2-x^2}
\end{aligned}
$$

因此，$y_{\max}=\left\lfloor\sqrt{(r+1)^2-x^2-\text{eps}}\right\rfloor$ 且 $y_{\min}=\left\lceil\sqrt{r^2-x^2}\right\rceil$。

单组数据时间复杂度 $O(r)$。

**【代码】**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
const int N = 1e5 + 5; const double EPS = 0.5;
int r, ans;
int f(int n) {
	return n * n;
}
void solve() {
	cin>>r;
	ans = 0;
	for(int i = 1; i <= r; i++) {
		int mx = floor(sqrt(f(r + 1) - f(i) - EPS));
		int mn = ceil(sqrt(f(r) - f(i)));
		// cout<<i<<" ["<<mn<<", "<<mx<<"]"<<endl;
		ans += mx - mn + 1;
	}
	cout<<ans * 4<<endl;
}
int t;
void file(string s) {
	freopen((s + ".in").c_str(), "r", stdin);
	freopen((s + ".out").c_str(), "w", stdout);
}
#define file(x) file(#x)
signed main() {
	// file(cf);
	cin>>t;
	while(t--) solve();
}
```

---

### Problem G. XOUR

**【题意】**

给定长度为 $n$ 的序列 $a$，每次操作选择交换 $a_i$ 和 $a_j$，需要满足 $a_i\text{ xor }a_j<4$。求进行不限次操作后字典序最小的序列。多测。

**【思路】**

观察到 $4=2^2$，因此 $a_i\text{ xor }a_j<4$ 当且仅当 $a_i$ 和 $a_j$ 在二进制下除后两位完全相同。

考虑据此分类，例如当 $a$ 为 $\{(0110)_2,(0100)_2,(1110)_2\}$ 时，应将前两个分为一组，剩下的单独成组。

为了使整个序列的字典序尽可能小，不妨在每组内从小到大排序，用优先队列维护是简单的。另注意到 $a_i$ 可达 $10^9$ 量级，应使用 map 维护。

单组数据时间复杂度 $O(n\log n)$。

**【代码】**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
const int N = 2e5 + 5;
int n, a[N];
map<int, priority_queue<int, vector<int>, greater<int>>> m;
void solve() {
	cin>>n;
	for(int i = 1; i <= n; i++) cin>>a[i];
	for(int i = 1; i <= n; i++) m[a[i] >> 2].push(a[i]);
	for(int i = 1; i <= n; i++) {
		cout<<m[a[i] >> 2].top()<<" ";
		m[a[i] >> 2].pop();
	}
	cout<<endl;
}
int t;
signed main() {
	cin>>t;
	while(t--) solve();
}
```