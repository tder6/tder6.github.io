令 $m=r-l+1$，不难有：

$$
\begin{aligned}
m^2\cdot s^2
&=m^2\cdot\frac1m\sum_{i=l}^r(a_i-\overline{a})^2 \\
&=m\sum_{i=l}^r(a_i^2-2a_i\overline{a}+\overline{a}^2) \\
&=m\left(\sum_{i=l}^r a_i^2-2\cdot\overline{a}\sum_{i=l}^r a_i+m\cdot\overline{a}^2\right)
\end{aligned}
$$

根据定义，将 $\displaystyle\overline{a}=\dfrac{1}{m}\cdot\sum_{i=l}^r a_i$ 代入，得：

$$
\begin{aligned}
m^2\cdot s^2
&=m\left(\sum_{i=l}^r a_i^2-2\cdot\overline{a}\sum_{i=l}^r a_i+m\cdot\overline{a}^2\right) \\
&=m\left(\sum_{i=l}^r a_i^2-2\cdot\left(\dfrac{1}{m}\cdot\sum_{i=l}^r a_i\right)\cdot\sum_{i=l}^r a_i+m\cdot\left(\dfrac{1}{m}\cdot\sum_{i=l}^r a_i\right)^2\right) \\
&=m\left(\sum_{i=l}^r a_i^2-\dfrac{2}{m}\cdot\left(\sum_{i=l}^r a_i\right)^2+\dfrac{1}{m}\cdot\left(\sum_{i=l}^r a_i\right)^2\right) \\
&=m\cdot\sum_{i=l}^r a_i^2-\left(\sum_{i=l}^r a_i\right)^2 \\
\end{aligned}
$$

观察到仅需维护区间和以及区间平方和即可，不难想到使用前缀维护。唯一问题是本题中是区间赋值，故不能用传统方式。

不妨举个例子来说明一下，将形如 $\text{A}$ 和 $\text{B}$ 等称作一个「赋值区间」：

![](https://cdn.luogu.com.cn/upload/image_hosting/yml9qqah.png)

此时 $(l_i,r_i)\in\{(1,4),(5,7),(8,8),(9,12)\}$。

若查询区间 $[p,q]=[2,10]$ 的方差，我们仅需知道该区间内的元素之和以及平方和即可。

观察到其中包含若干个完整的赋值区间（在本例中是 $\text{B}$ 和 $\text{C}$），以及一个在开头位置的不完整的赋值区间（在本例中是 $\text{A}$）和一个在结尾位置的不完整的赋值区间（在本例中是 $\text{D}$）。

不妨令开头和结尾处的不完整区间的编号分别为 $x$ 和 $y$，观察到给定的赋值区间序列是单调的，故可以通过二分在 $O(\log m)$ 的复杂度内求出其编号。

对于完整赋值区间部分，可以预处理出前缀 $\displaystyle c_i=\sum_{j=1}^{r_i}a_j$，若朴素处理复杂度为 $O(n)$ 是不可取的。考虑变形成 $\displaystyle\sum_{j=1}^{i}(r_i-l_i+1)\cdot b_j$，即每个赋值区间内元素的和加起来，这么做是 $O(m)$ 的，可以接受。那么完整区间部分的区间和即为 $c_{y-1}-c_{x}$。

而对于开头结尾的不完整部分，显然的，区间和分别为 $(r_x-p+1)\cdot b_x$ 和 $(p-l_y+1)\cdot b_y$。

综上，区间 $[p,q]$ 中元素之和为：

$$
\sum_{i=p}^qa_i=(c_{y-1}-c_{x})+(r_x-p+1)\cdot b_x+(p-l_y+1)\cdot b_y
$$

区间平方和同理。

于是可以用 $O(m)$ 预处理，加上 $O(\log m)$ 的单次查询，总复杂度 $O(m+q\log m)$。

具体实现时可用 modint，注意特判 $x=y$ 的情况。

---

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
const int N = 1e6 + 5, M = 998244353;
template<int Mod, int Value = (int)1e18>
class Modint {
	public:
		int v = 0, V = Mod;
		Modint(int x = 0): v(x % Mod) {
			V = (Value / Mod + 1) * Mod;
		};
		operator int() {
			return v;
		}
		Modint operator+(int x) {
			return (v + x + V) % Mod;
		}
		Modint operator-(int x) {
			return (v - x + V) % Mod;
		}
		Modint operator*(int x) {
			return (v * x + V) % Mod;
		}
		Modint operator/(int x) {
			return (v / x + V) % Mod;
		}
		Modint operator%(int x) {
			return v % x;
		}
		Modint operator&(int x) {
			return ((v & x) + V) % Mod;
		}
		Modint operator|(int x) {
			return ((v | x) + V) % Mod;
		}
		Modint operator^(int x) {
			return ((v ^ x) + V) % Mod;
		}
		Modint operator~() {
			return (~v + V) % Mod;
		}
		Modint operator++(signed x) {
			auto p = *this;
			*this = *this + 1;
			return p;
		}
		Modint& operator++() {
			*this = *this + 1;
			return *this;
		}
		Modint operator--(signed x) {
			auto p = *this;
			*this = *this - 1;
			return p;
		}
		Modint& operator--() {
			*this = *this - 1;
			return *this;
		}
		Modint operator+=(int x) {
			*this = *this + x;
			return *this;
		}
		Modint operator-=(int x) {
			*this = *this - x;
			return *this;
		}
		Modint operator*=(int x) {
			*this = *this * x;
			return *this;
		}
		Modint operator/=(int x) {
			*this = *this / x;
			return *this;
		}
		Modint operator%=(int x) {
			*this = *this % x;
			return *this;
		}
		Modint operator&=(int x) {
			*this = *this & x;
			return *this;
		}
		Modint operator|=(int x) {
			*this = *this | x;
			return *this;
		}
		Modint operator^=(int x) {
			*this = *this ^ x;
			return *this;
		}
};
#define mint Modint<M>
int n, m, q, l[N], r[N]; mint b[N], c1[N], c2[N];
signed main() {
	cin>>n>>m>>q;
	for(int i = 1; i <= m; i++) {
		int x, y, z; cin>>x>>y>>z;
		l[i] = x, r[i] = y, b[i] = z;
	}
	for(int i = 1; i <= m + 1; i++) c1[i] = c1[i - 1] + b[i] * mint(r[i] - l[i] + 1);
	for(int i = 1; i <= m + 1; i++) c2[i] = c2[i - 1] + b[i] * b[i] * mint(r[i] - l[i] + 1);
	while(q--) {
		int i, j; cin>>i>>j;
		int x = upper_bound(l + 1, l + m + 1, i) - l - 1, y = upper_bound(l + 1, l + m + 1, j) - l - 1;
		mint s1, s2;
		if(x != y) s1 = (c1[y - 1] - c1[x]) + b[x] * mint(r[x] - i + 1) + b[y] * mint(j - l[y] + 1);
		else s1 = b[x] * mint(j - i + 1);
		if(x != y) s2 = (c2[y - 1] - c2[x]) + b[x] * b[x] * mint(r[x] - i + 1) + b[y] * b[y] * mint(j - l[y] + 1);
		else s2 = b[x] * b[x] * mint(j - i + 1);
		cout<<s2 * mint(j - i + 1) - s1 * s1<<endl;
	}
}
```