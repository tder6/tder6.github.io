很好的 trick 啊。

显然的，答案在二进制下的第 $i$ 位为 $1$ 一定比该位为 $0$ 更优。故考虑从高到低枚举答案的二进制位，若该位可取 $1$ 则必定贪心取 $1$，而根据这个结果再去检查后面更低位能否取。

下面问题在于如何检验第 $i$ 位是否可行。由于只能合并相邻两项，故合并 $k$ 次相当于将原序列分为 $n-k$ 段，每一段内按位或。因此，考虑用 $p$ 维护当前段内的按位或值，若某一时刻 $p$ 二进制下第 $i$ 位为 $1$，且与已得出的更高位部分的答案不矛盾，则可以贪心的开启新的一段。最后仅需判断段数是否不小于 $n-k$ 即可。 

时间复杂度 $O(n\log V)$。

---

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
const int N = 2e5 + 5, V = 30;
int n, k, a[N], ans;
bool check(int d) {
	int r = 0, p = 0;
	for(int i = 1; i <= n + 1; i++) {
		p |= a[i];
		if((p & d) == d) r++, p = 0;
	}
	return r >= k;
}
signed main() {
	cin>>n>>k; k = n - k;
	for(int i = 1; i <= n; i++) cin>>a[i];
	for(int i = V; i >= 0; i--) if(check(ans + (1 << i))) ans += (1 << i);
	cout<<ans<<endl;
}
```