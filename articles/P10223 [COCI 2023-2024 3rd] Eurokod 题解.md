很水的排序。

首先定义结构体，具体的：

- $\text{id}_i$ 表示第 $i$ 个人的编号，用于防止中途排序被打乱；
- $\text{leaderorder}_i$ 表示组长给其的排序，$\text{leaderscore}_i$ 表示其组长得分；
- $\text{otherstotal}_i$ 表示组员给其的票数，$\text{othersscore}_i$ 表示其组员得分；
- $\text{score}_i$ 表示总得分。

那么，根据定义，显然有：

- $\text{id}_i=i$；
- $\text{leaderscore}_i=n-\text{leaderorder}_i+1$；
- 令已根据组员给其的票数从大到小排序，即对于任意的 $x\in[1,n)$ 都有 $\text{otherstotal}_x>\text{otherstotal}_{x+1}$，则 $\text{othersscore}_i=n-i+1$；
- $\text{score}_i=\text{leaderscore}_i+\text{othersscore}_i$。

于是排序模拟即可，另外介绍一些比较基础的具体实现：

- `sort` 函数可以附带比较函数 `cmp`，参数为两个同类型的变量 $x,y$，当且仅当排序后 $x$ 应在 $y$ 之前时返回 $1$；
- 三元运算符 `(a ? b : c)`，当且仅当 $a$ 为真时返回 $b$，反之返回 $c$，即为：

```
Get(a, b, c):
    If a:
        Return b
    Else:
        Return c
```

时间复杂度 $O(n\log n)$。

---

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 5;
int n;
struct Node {
    int id, leaderorder, leaderscore, otherstotal, othersscore, score;
} a[N];
bool cmp1(Node x, Node y) {
    return x.otherstotal > y.otherstotal;
}
bool cmp2(Node x, Node y) {
    if(x.score != y.score) return x.score > y.score;
    else return x.othersscore > y.othersscore;
}
signed main() {
    cin>>n;
    for(int i = 1; i <= n; i++) a[i].id = i;
    for(int i = 1; i <= n; i++) {
        int x; cin>>x;
        a[x].leaderorder = i;
    }
    for(int i = 1; i <= n; i++) a[i].leaderscore = n - a[i].leaderorder + 1;
    for(int i = 1; i <= n; i++) cin>>a[i].otherstotal;
    sort(a + 1, a + n + 1, cmp1);
    for(int i = 1; i <= n; i++) a[i].othersscore = n - i + 1;
    for(int i = 1; i <= n; i++) a[i].score = a[i].leaderscore + a[i].othersscore;
    sort(a + 1, a + n + 1, cmp2);
    for(int i = 1; i <= n; i++) cout<<i<<". Kod"<<((a[i].id < 10) ? "0" : "")<<a[i].id<<" ("<<a[i].score<<")"<<endl;
}
```